= 15.4.22 整理 iOS 面试题 （一）
:hp-alt-title: iOS interview part 1

=== 起源
在知乎上看到了这么一个问题
http://www.zhihu.com/question/19604641/answer/44151044

标题是 “如何面试 iOS 工程师？” 我很有兴趣，以为马上也该找实习公司了，必须刷一下面试题，正好可以看看 iOS 面试题难度如何。

本文章会做成连续的博客，用于解答该问题点赞数最多的那个回答（是一个面试题列表），我认为很值得较真一下，一篇博客回答一个问题。本文是第一篇，也是第一个问题。

=== Question
===== 什么是arc？（arc是为了解决什么问题诞生的？）

arc 是 Automatic Reference Counting 的缩写，中文译为 “自动引用计数” 是为了正确管理对象，释放内存的一种内存管理机制。

在 arc 之前，是程序员手动管理内存的。就像这样

```
//实例化对象
NSObject *obj = [[NSObject alloc] init];

//如有需求，可以增加持有，这样可以使引用计数器 +1 
//就像这样 [obj retain];

//使用完毕后释放，这样可以使引用计数器 -1
[obj release];
```

而 arc 的好处就在于，当你写完代码以后，编译过程中，编译器能知道你再某一个地方需要加上这些代码，然后在这些位置帮你加上。使得你可以解放你的双手和大脑去关注代码的逻辑，而不是内存。

有时候，我们往往会因为一时疏忽而漏写释放的代码，导致内存泄露，如果代码量一大，或者过于复杂，你很难排查，arc就解决了这样的问题，编译器可不会疏忽任何一段代码。可以大大减少程序内存泄露的可能性。

但是 arc 下还是有可能会出现内存泄露的问题，最常见的就是循环引用，就是 A 对象里有一个对 B 对象的引用，而 B 对象也有一个对 A 对象的引用，那么两个对象互相持有对方，导致引用计数器始终为 1 ，而不能进行释放。这个时候，只需要一方使用 weak 关键字，就能解除这样的循环，常见的就是 delegate ，这也是为什么所有的 delegate 属性都存在 weak 关键字。

下一个问题，写在下篇。